[extension_name]
SAMMIVeadotubeMiniExtension

[extension_info]
This is a basic extension for SAMMI that implements functionalities to manipulate Veadotube Mini. By Benjas333

[extension_version]
$!VERSIONNUMBER!$

[insert_external]
<style type="">
* {
        box-sizing: border-box;
}
.switch-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
}
.switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 25px;
        background-color: #ccc;
        border-radius: 25px;
}
.switch input {
        opacity: 0;
}
.slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 25px;
}
.slider:before {
        position: absolute;
        content: "";
        height: 19px;
        width: 19px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
}
input:checked + .slider {
        background-color: #4CAF50;
}
input:checked + .slider:before {
        transform: translateX(24px);
}
</style>
<div class="row">
        <h1>Veadotube Mini Extension</h1>
        <p>Interact and manipulates Veadotube Mini through the Veadotube Mini's websocket.</p>
</div>
<div class="row">
        <div class="column">
                <p>Created by Benjas333</p>
                <a href="https://x.com/ElBenjas333">Twitter.</a>
                <a href="https://github.com/Benjas333/SAMMIVeadotubeMiniExtension">GitHub.</a>
                <p>Version: $!VERSIONNUMBER!$</p>
                <span>Websocket server:</span>
                <input type="text" id="veadotube-websocket-server">
                <p></p>
                <span>Window title:</span>
                <input type="text" id="veadotube-window-title">
                <div>
                        <p>Status: <span id="veadotube-connection-status">Disconnected</span>
                        <button class="btn btn-primary btn-sm" onclick="updateHTMLStatus();">Force Refresh WebSocket Status</button></p>
                </div>
                <div class="switch-container">
                        <label class="switch">
                                <input type="checkbox" id="toggleSlider">
                                <span class="slider"></span>
                        </label>
                        <span>Auto-reconnect if connection is lost?</span>
                </div>
                <button class="btn btn-primary btn-sm" onclick="connectWebsocket();">Connect websocket</button>
                <button class="btn btn-primary btn-sm" onclick="requestStatesRefresh();">Refresh Avatar States</button>
        </div>
</div>

[insert_command]
SAMMIVM_initialize();

[insert_hook]


[insert_script]
let veadotube_mini_server = () => {
        const inputServer = document.getElementById("veadotube-websocket-server");
        const inputName = document.getElementById("veadotube-window-title");
        return `ws://${inputServer.value}?n=${inputName.value}`;
};
let veadotube_mini_auto_reconnect = false;

const VEADOTUBE_MINI_PLUGIN_NAME = 'SAMMIVeadotubeMiniExtension';
const VEADOTUBE_MINI_NODES_PREFIX = 'nodes:'

const VEADOTUBE_MINI_WebSocket_StringStates = {
        0: "Connecting...",
        1: "Connected",
        2: "Disconnecting...",
        3: "Disconnected"
};

class VEADOTUBE_MINI_LOGGER {
        static log(message) {
                console.log(VEADOTUBE_MINI_PLUGIN_NAME + ": " + message);
        }
        static debug(message) {
                console.debug(VEADOTUBE_MINI_PLUGIN_NAME + ": " + message);
        }
        static info(message) {
                SAMMI.notification("VEADOTUBE_MINI: " + message);
                console.info(VEADOTUBE_MINI_PLUGIN_NAME + ": " + message);
        }
        static warn(message) {
                SAMMI.alert("VEADOTUBE_MINI: " + message);
                console.warn(VEADOTUBE_MINI_PLUGIN_NAME + ": " + message);
        }
        static error(message) {
                SAMMI.alert("VEADOTUBE_MINI: " + message);
                console.error(VEADOTUBE_MINI_PLUGIN_NAME + ": " + message);
        }
}

const saveAsVariableBox = ["Save Variable As", 14, ""];
const saveOldStateAsVariableBox = ["Save Previous State As", 14, ""];

function SAMMIVM_InsertBaseCommands() {
        SAMMI.extCommand('Veadotube mini - Peek State', 3355443, 52, {
                variable: saveAsVariableBox
        });

        SAMMI.extCommand('Veadotube mini - Set State', 3355443, 52, {
                state: ['State to set', 20, '', null, ['No States detected! Is the WebSocket connected?']],
                oldState: saveOldStateAsVariableBox
        });

        SAMMI.extCommand('Veadotube mini - Push State', 3355443, 52, {
                state: ['State to push', 20, '', null, ['No States detected! Is the WebSocket connected?']],
                oldState: saveOldStateAsVariableBox
        });

        SAMMI.extCommand('Veadotube mini - Pop State', 3355443, 52, {
                state: ['State to pop', 20, '', null, ['No States detected! Is the WebSocket connected?']],
                oldState: saveOldStateAsVariableBox
        });

        SAMMI.extCommand('Veadotube mini - Thumb State', 3355443, 52, {
                state: ['State to thumb', 20, '', null, ['No States detected! Is the WebSocket connected?']],
                variable: saveAsVariableBox
        });
}

function SAMMIVM_InsertCommandHooks() {
        sammiclient.on('Veadotube mini - Peek State', async (json) => {
                const SAMMI_JSON = json.Data;
                window[`${VEADOTUBE_MINI_PLUGIN_NAME}_Queues`].peek.push((websocketResponse) => {
                        if (!!SAMMI_JSON.variable) SAMMI.setVariable(SAMMI_JSON.variable, websocketResponse, SAMMI_JSON.FromButton);
                })

                requestPeekState();
        });

        sammiclient.on('Veadotube mini - Set State', async (json) => {
                const SAMMI_JSON = json.Data;
                // HACK: Used peek queue because websocket response always contains peek instead of set
                window[`${VEADOTUBE_MINI_PLUGIN_NAME}_Queues`].peek.push((websocketResponse) => {
                        if (!!SAMMI_JSON.oldState) SAMMI.setVariable(SAMMI_JSON.oldState, websocketResponse, SAMMI_JSON.FromButton);
                })

                requestSetState(window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`][SAMMI_JSON.state]);
        });

        sammiclient.on('Veadotube mini - Push State', async (json) => {
                const SAMMI_JSON = json.Data;
                // HACK: Used peek queue because websocket response always contains peek instead of push
                window[`${VEADOTUBE_MINI_PLUGIN_NAME}_Queues`].peek.push((websocketResponse) => {
                        if (!!SAMMI_JSON.oldState) SAMMI.setVariable(SAMMI_JSON.oldState, websocketResponse, SAMMI_JSON.FromButton);
                })

                requestPushState(window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`][SAMMI_JSON.state]);
        });

        sammiclient.on('Veadotube mini - Pop State', async (json) => {
                const SAMMI_JSON = json.Data;
                // HACK: Used peek queue because websocket response always contains peek instead of pop
                window[`${VEADOTUBE_MINI_PLUGIN_NAME}_Queues`].peek.push((websocketResponse) => {
                        if (!!SAMMI_JSON.oldState) SAMMI.setVariable(SAMMI_JSON.oldState, websocketResponse, SAMMI_JSON.FromButton);
                })

                requestPopState(window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`][SAMMI_JSON.state]);
        });

        sammiclient.on('Veadotube mini - Thumb State', async (json) => {
                const SAMMI_JSON = json.Data;
                // NOTE: The only one that websocket actually returns thumb
                window[`${VEADOTUBE_MINI_PLUGIN_NAME}_Queues`].thumb.push((websocketResponse) => {
                        if (!!SAMMI_JSON.variable) SAMMI.setVariable(SAMMI_JSON.variable, websocketResponse, SAMMI_JSON.FromButton);
                })

                requestThumbState(window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`][SAMMI_JSON.state]);
        });
}

function interpretResponse(responseData) {
        if (!responseData) throw 'interpretResponse: responseData cannot be null';
        
        if (responseData.event !== 'payload') VEADOTUBE_MINI_LOGGER.warn("Received an unhandled event value: " + responseData.event + "\nRaw response data: " + responseData)

        if (responseData.type !== 'stateEvents') VEADOTUBE_MINI_LOGGER.warn("Received an unhandled type value: " + responseData.type + "\nRaw response data: " + responseData)

        if (responseData.id !== 'mini') VEADOTUBE_MINI_LOGGER.warn("Received an unhandled id value: " + responseData.id + "\nRaw response data: " + responseData)

        let payload = responseData.payload;
        let arg = {};
        switch (payload.event) {
                case "list":
                        VEADOTUBE_MINI_LOGGER.info(`Found ${payload.states.length} Avatar States.`);
                        window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`] = {};
                        payload.states.forEach(element => {
                                window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`][element.name] = element.id;
                        });

                        let state_names = Object.keys(window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`]);

                        SAMMI.extCommand('Veadotube mini - Set State', 3355443, 52, {
                                state: ['State to set', 20, '', null, state_names],
                                oldState: saveOldStateAsVariableBox
                        });

                        SAMMI.extCommand('Veadotube mini - Push State', 3355443, 52, {
                                state: ['State to push', 20, '', null, state_names],
                                oldState: saveOldStateAsVariableBox
                        });

                        SAMMI.extCommand('Veadotube mini - Pop State', 3355443, 52, {
                                state: ['State to pop', 20, '', null, state_names],
                                oldState: saveOldStateAsVariableBox
                        });

                        SAMMI.extCommand('Veadotube mini - Thumb State', 3355443, 52, {
                                state: ['State to thumb', 20, '', null, state_names],
                                variable: saveAsVariableBox
                        });
                        break;
                case "thumb":
                        arg = {
                                ...arg,
                                width: payload.width,
                                height: payload.height,
                                png: payload.png
                        }
                case "peek":
                case "set":
                case "push":
                case "pop":
                        let func = window[`${VEADOTUBE_MINI_PLUGIN_NAME}_Queues`][payload.event].shift();
                        if (!func) break;
                        arg = {
                                name: Object.keys(window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`]).filter(key => window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`][key] === payload.state)[0],
                                id: payload.state,
                                ...arg,
                        };
                        func(arg);
                        break;
                default:
                        VEADOTUBE_MINI_LOGGER.warn("Received an unknown event payload value: " + payload.event + "\nRaw response payload: " + payload);
                        break;
        }
}

function createVMWebSocket(callback = null) {
        VEADOTUBE_MINI_LOGGER.log('Checking client');
        if (window.VEADOTUBE_MINI_WebSocket) {
                if (getWebSocketStatus() === WebSocket.CLOSING && veadotube_mini_auto_reconnect) {
                        VEADOTUBE_MINI_LOGGER.warn('Closure pending, waiting 5 seconds to reconnect.');
                        setTimeout(() => { createVMWebSocket(callback); }, 5000);
                        return;
                }
                if (getWebSocketStatus() !== WebSocket.CLOSED) {
                        if (callback) callback();
                        return;
                }
        }
        
        window.VEADOTUBE_MINI_WebSocket = new WebSocket(veadotube_mini_server());

        window.VEADOTUBE_MINI_WebSocket.onmessage = (event) => {
                updateHTMLStatus();
                if (!event.data) {
                        VEADOTUBE_MINI_LOGGER.warn("Response data was empty");
                        return;
                }
                if (!event.data.startsWith(VEADOTUBE_MINI_NODES_PREFIX)) {
                        VEADOTUBE_MINI_LOGGER.warn(`Response data was sent from an unhandled channel. Raw response: ${event.data}`);
                        return;
                }
                const sanitizedMessage = event.data.trim().replace(/[\u0000-\u001F\u007F-\u009F]/g, "");
                const responseData = JSON.parse(sanitizedMessage.replace(VEADOTUBE_MINI_NODES_PREFIX, ''));
                interpretResponse(responseData);
        }

        window.VEADOTUBE_MINI_WebSocket.onclose = (event) => {
                updateHTMLStatus();
                VEADOTUBE_MINI_LOGGER.debug(`Disconnected(${event.code || "No code provided"}, ${event.reason || "No reason provided"})`);
                VEADOTUBE_MINI_LOGGER.warn('Socket disconnected.');
                if (veadotube_mini_auto_reconnect) {
                        VEADOTUBE_MINI_LOGGER.warn("Re-connecting in 5 seconds...");
                        setTimeout(createVMWebSocket, 5000);
                }
        }

        window.VEADOTUBE_MINI_WebSocket.onopen = (event) => {
                VEADOTUBE_MINI_LOGGER.info("WebSocket successfully connected!");
                updateHTMLStatus();
                if (callback) callback();
        }

        window.VEADOTUBE_MINI_WebSocket.onerror = (error) => {
                updateHTMLStatus("An error has occurred.");
                VEADOTUBE_MINI_LOGGER.error(`Socket error: ${error || "No error provided"}`);
        }
}

function sendNodesMessageToVeadotubeMini(request) {
        if (!window.VEADOTUBE_MINI_WebSocket) {
                VEADOTUBE_MINI_LOGGER.warn("WebSocket is not connected.");
                return;
        }
        let webSocketStatus = getWebSocketStatus();
        if (webSocketStatus !== WebSocket.OPEN) VEADOTUBE_MINI_LOGGER.warn(`Connection pending (${webSocketStatus})`);

        switch (webSocketStatus) {
                case WebSocket.OPEN:
                        const str = JSON.stringify(request);
                        window.VEADOTUBE_MINI_WebSocket.send(VEADOTUBE_MINI_NODES_PREFIX + str);
                        break;
                case WebSocket.CLOSING:
                        if (veadotube_mini_auto_reconnect) setTimeout(createVMWebSocket, 5000);
                        break;
                case WebSocket.CLOSED:
                        if (veadotube_mini_auto_reconnect) createVMWebSocket();
                        break;
                case WebSocket.CONNECTING:
                        setTimeout(() => { sendNodesMessageToVeadotubeMini(request); }, 3000);
                        break;
                default:
                        VEADOTUBE_MINI_LOGGER.info("Wtf?");
                        break;
        }
}

async function requestPeekState() {
        let request = await SAMMIVM_generateStateEventsPayloadRequest("peek");
        sendNodesMessageToVeadotubeMini(request);
}

async function requestSetState(stateID) {
        let request = await SAMMIVM_generateStateEventsPayloadRequest("set");
        request.payload.state = stateID;
        sendNodesMessageToVeadotubeMini(request);
}

async function requestPushState(stateID) {
        let request = await SAMMIVM_generateStateEventsPayloadRequest("push");
        request.payload.state = stateID;
        sendNodesMessageToVeadotubeMini(request);
}

async function requestPopState(stateID) {
        let request = await SAMMIVM_generateStateEventsPayloadRequest("pop");
        request.payload.state = stateID;
        sendNodesMessageToVeadotubeMini(request);
}

async function requestThumbState(stateID) {
        let request = await SAMMIVM_generateStateEventsPayloadRequest("thumb");
        request.payload.state = stateID;
        sendNodesMessageToVeadotubeMini(request);
}

async function requestListState() {
        let request = await SAMMIVM_generateStateEventsPayloadRequest("list");
        sendNodesMessageToVeadotubeMini(request);
}

async function SAMMIVM_generateStateEventsPayloadRequest(event) {
        if (getWebSocketStatus() !== WebSocket.OPEN) VEADOTUBE_MINI_LOGGER.warn("Warning - WebSocket is not connected. Command will not work properly.");
        return {
                "event": "payload",
                type: "stateEvents",
                id: "mini",
                payload: {
                        "event": event
                }
        }
}

function requestStatesRefresh() {
        VEADOTUBE_MINI_LOGGER.log("Refreshing Avatar States list...");
        requestListState();
}

function connectWebsocket() {
        // VEADOTUBE_MINI_LOGGER.info("Connecting WebSocket...");
        createVMWebSocket(requestStatesRefresh);
}

function updateHTMLStatus(customStatus = "") {
        const statusElement = document.getElementById("veadotube-connection-status");
        statusElement.innerText = customStatus.length ? customStatus : !!window.VEADOTUBE_MINI_WebSocket ? VEADOTUBE_MINI_WebSocket_StringStates[window.VEADOTUBE_MINI_WebSocket.readyState] : VEADOTUBE_MINI_WebSocket_StringStates[3];
}

function getWebSocketStatus() {
        updateHTMLStatus();
        return window.VEADOTUBE_MINI_WebSocket.readyState;
}

// COMMENT: Not necessary at the moment
// function uuidv4() {
//         return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
//                 var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
//                 return v.toString(16);
//         });
// }

function SAMMIVM_initialize() {
        if (!sammiclient) {
                setTimeout(SAMMIVM_initialize, 1000);
                return;
        }

        VEADOTUBE_MINI_LOGGER.info("Started $!VERSIONNUMBER!$");
        
        if (!window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`]) window[`${VEADOTUBE_MINI_PLUGIN_NAME}_States`] = {};
        if (!window[`${VEADOTUBE_MINI_PLUGIN_NAME}_Queues`]) {
                window[`${VEADOTUBE_MINI_PLUGIN_NAME}_Queues`] = {
                        peek: [],
                        set: [],
                        push: [],
                        pop: [],
                        thumb: [],
                };
        }
        SAMMIVM_InsertBaseCommands();
        SAMMIVM_InsertCommandHooks();
        const toggleSlider = document.getElementById('toggleSlider');
        toggleSlider.addEventListener('change', () => {
                veadotube_mini_auto_reconnect = toggleSlider.checked;
        })
}

[insert_over]
{"exampleDeckData":"$!ExampleDeckData!$"}
